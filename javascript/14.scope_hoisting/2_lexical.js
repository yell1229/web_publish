// lexical(렉시컬) : 실행컨텍스트안에 포함된 개념으로 스코프별로 메모리를 효율성 있게 관리하는 영역
// 변수선언, 실행코드, 외부호출 코드
// 콜스택(Call Stack) - 호출되는 코드(함수)를 순차적으로 실행
// 변수의 선언시 let, const를 활용하여 정확한 스코프 범위 설정 중요!!!
{ // 전역 스코프
    let a = 10;
    console.log(`a => ${a}`);
   // console.log(`aa => ${aa}`); // undefined

    { // 지역 스코프
        let b = 20;
        var aa = 100; // 전역으로 선언됨
        console.log(`b => ${b}`);
        console.log(`aa => ${aa}`); 
        
        {
            let c = 30;
            console.log(`c => ${c}`);
            console.log(`a => ${a}`);
            console.log(`b => ${b}`);
        }// level 2

    }// level 1
    
}// 전역 스코프

// V8의 구조 : 싱글쓰레드(일을 담당하는 것 1개: 일반서버를 대체할 수 없다.) 형식 => 해당 개념을 가지고 있는 것이 콜스택!!

// 실행컨텍스트 오브젝트( 포함범위 : 변수저장환경, 렉시컬 환경, eval function)
// js파일의 내용을 인터프리터 형식으로 끝까지 읽고, 스코프의 갯수에 따라서 렉시컬 환경에 스코프 영역을 나누어 저장한다. Lexical Environment
// 전역 스코프의 변수, 실행코드, 외부연결을 전역 스코프에 넣는다.
// level 1의 영역을 잡고 변수, 실행코드, 외부연결을 level 1에 넣는다.
// level 2의 영역을 잡고 변수, 실행코드, 외부연결을 level 2에 넣는다.


// 화면 설명
// 실행컨텍에서 a를 저장한다. 콜스택에서 변수 a를 요청하면 실행컨텍스트에서 a를 찾아서 콜스텍에 전달한다.
// 실행컨텍에서 변수 b를 렉시컬영역에 레코드 정보를 저장한다. 콜스택에서 변수 b를 요청하면 실행컨텍스트에서 b를 찾아서 콜스텍에 전달한다.
// 실행컨텍에서 변수 c를 렉시컬영역에 레코드 정보를 저장한다. 콜스택에서 변수 b를 요청하면 실행컨텍스트에서 c를 찾아서 콜스텍에 전달한다.
// 콜스택에서 a를 요청한다. 실행컨텍스트에서 level 2로 가서 a를 찾는다. 없으면 스코프체이닝을 통해 level 1으로 올라간다. 거기도 없으면 전역으로 넘어가서 a를 찾는다. 찾으면 콜스텍에 전달한다.

// 렉시컬 영역 : 레코드 정보 /  외부 레코드 참조(scope channing)상위로만 참조 가능하다.


/*
var는 전역변수,
let, const는 {}영역에 있으므로 var는 사용하지 않는다.
*/

// ---------------------------------------------------------------------------------------------------


















